# 2021 카카오 채용연계형 인턴십 표편집[Lv3]](https://programmers.co.kr/learn/courses/30/lessons/17676)


## 틀린(못푼) 이유 
* 구현한 알고리즘이 효율성테스트 통과를 못하는 코드임을 논리적으로 생각하지 못하였다. 
* 이로인해 효율성 통과를 못하는 코드를 계속해서 붙잡고, 같은 논리의 알고리즘을 최적화하는 시간낭비를하게 되었다.
* **효율성통과를 위한 아이디어를 떠올리지 못하면 틀린것이니 답을보고 넘어가자. 아무리 최적화해도 효율성 통과를 하지못한다.**

## 문제해결 아이디어

### 개념
* 표 편집 문제에서는 특정 자료구조에 삽입, 삭제, 검색과 비슷한 행위들을 반복하여 수행해야 함을 알 수 있다.

#### 오류(리스트 배열의 시간복잡도)
1. 가장먼저 떠오르는 자료구조는 기본적인 배열이다. 파이썬 list함수로 배열을 만들고, 삽입,삭제가 발생할때마다 list(index) 삽입, 삭제를 시행하였다. 그러나 최악의경우 n은 1,000,000 이고, cmd는  200,000이며 O(n)의 시간복잡도가 발생한다면, n x cmd x 시간복잡도가 생기므로, 비효율적임을 알 수 있다. 
```python
######## 정확도 100% , 효율성 0% 코드 ########
def solution(n, k, cmd):
    matrix=[i for i in range(n)]
    cursor= k
    deleted=[]
    for command in cmd:
        # C : 현재 선택된 행 제거
        if command=='C':
            deleted.append([cursor,matrix[cursor]])
            #현재 커서가 맨끝항일때
            if cursor==len(matrix)-1:
                matrix.pop()
                cursor-=1
            else:
                #@@효율성 문제가 되는코드1 : command 발생할때마다 O(N)
                matrix.pop(cursor)
        # Z : 가장최근에 삭제된 행 복구
        elif command=='Z':
            tmp=deleted.pop()
            #@@효율성 문제가 되는코드2 : command 발생할때마다 O(N)
            matrix.insert(tmp[0],tmp[1])
            #커서 인덱스가 최근삭제한 인덱스보다 큰경우 
            if cursor>=tmp[0]:
                cursor+=1
        else:
            direction,x =command.split()
            if direction=='U':
                cursor-=int(x)
            else:
                cursor+=int(x)                    
    answer=[0]*n
    for x in matrix:
        answer[x]=1
    res=''
    for x in answer:
        if x==1:
            res+='O'
        else:
            res+='X'  
    return res
```

2. 배열로는 도저히 효율성 테스트를 통과하지 못하는것을 파악하지 못하여서, 배열풀이를 최적화를 이유로 삽질을 하였다. cmd 삽입, 삭제 시 발생하는 시간복잡도 O(n)을 줄이기위해 **해당 인덱스에 삭제여부 flag를 주었다.** 그러나 코드를 보면 알듯이 과도한 while문 남발을 하였고, 근본적인 시간복잡도는 1번과 동일한 n x cmd x O(n)이다. 다만, 효율성테스트 절반을 통과할 수 있었던 이유는 O(N)도 O(N)을 나름 최적화하여 통과하는 테스트케이스가 존재하는 것일뿐이니, **절반을 맞은게 아니라 얻어맞은것이기에 전부틀린것이다.**
```python
######## 정확도 100% , 효율성 50% 코드 ########
def solution(n, k, cmd):
    # matrix[i][0] : 인덱스 i번째 배열 값, matrix[i][1] : 인덱스 i번째 배열 값 존재여부
    matrix = [[i, 0] for i in range(n)]
    cursor = k
    deleted = []
    for command in cmd:
        # C: 현재 선택된 행 제거 , C 명령이 호출될떄 Cursor는 항상 flag 0 인값에 위치함
        if command == 'C':
            matrix[cursor][1] = 1
            deleted.append(cursor)
            tmp = cursor
            tmp += 1
            isFinal = True
            # 마지막 커서에 있는지확인
            while tmp <= n - 1:
                if matrix[tmp][1] == 0:
                    # 마지막 커서에 있지않는경우 : 커서위치조정
                    cursor = tmp
                    isFinal = False
                    break
                tmp += 1
            # 마지막커서에 해당한다면
            if isFinal:
                cursor -= 1
                while cursor >= 0:
                    if matrix[cursor][1] == 0:
                        break
                    cursor -= 1
        # Z=가장최근에 삭제된 행 복구
        elif command == 'Z':
            deletedCursor = deleted.pop()
            matrix[deletedCursor][1] = 0
        else:
            direction, x = command.split()
            x = int(x)
            #문자열실수
            if direction=='U':
                cnt=0
                while True:
                   # print(direction,x,cnt,cursor, matrix)
                    cursor -= 1
                    if matrix[cursor][1]==0:
                        cnt+=1
                    if cnt==x:
                        break
            elif direction == 'D':
                cnt=0
                while True:
                    cursor += 1
                    if matrix[cursor][1]==0:
                        cnt+=1
                    if cnt==x:
                        break
    res=''
    for idx,val in matrix:
        if val==1:
            res+='X'
        else:
            res+='O'
    return res
```


#### 링크드리스트 
1.~ **응답시작시간<=응답처리시간<=응답완료시간**이다.






### 핵심
* 전위/중위/후위순회는 재귀함수와 관련있는문제이다. 코드는 같지만, 출력순서를 어떻게 하느냐에따라 순회가 달라진다.
* 문제에서도 나와있듯, 항상 A가 루트노드가 된다.



### 알고리즘
 1. A,B...Y,Z를 dict()의 하나의 key로 처리한다. 
 2. 각각의 dict()의 Val 값은 [왼쪽자식, 오른쪽자식]의 값을 가지게한다. tree[A] =[A의왼쪽자식,A의오른쪽자식]
 3. 과정 1~2를 반복하며 전위/중위/후위 순회에 맞게 print 재귀함수를 시행한다. 


### 정답코드 

```python

import sys
sys.stdin=open('a.txt','r')

N = int(input())
tree = {}

for _ in range(N):
    node, left, right = input().split()
    tree[node] = [left, right]


def preOrder(node):
    if node == '.':
        return

    print(node, end="")
    preOrder(tree[node][0])
    preOrder(tree[node][1])


def inOrder(node):
    if node == '.':
        return

    inOrder(tree[node][0])
    print(node, end="")
    inOrder(tree[node][1])


def postOrder(node):
    if node == '.':
        return

    postOrder(tree[node][0])
    postOrder(tree[node][1])
    print(node, end="")

#A가 최상위 root이므로 'A' 대입부터 시작
preOrder('A')
print()
inOrder('A')
print()
postOrder('A')

```

### 코드이해 TiP 
 1. 재귀함수는 직접 스택에 넣어보면서 동작상태원리를 이해한다.
 2.  전위/중위/후위 순위 프로그래밍 순서대로 큐에 넣고 실행되는 출력값을 직접구해보면 이해에 도움이 된다. (아직도 어렵다..)



## 참고

[github 마크다운](https://ffoorreeuunn.tistory.com/226)

[참고코드1](https://kjhoon0330.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%91%9C-%ED%8E%B8%EC%A7%91-Python)


