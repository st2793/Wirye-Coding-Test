# 2021 카카오 채용연계형 인턴십 미로탈출[Lv4]](https://programmers.co.kr/learn/courses/30/lessons/81304)


## 틀린(못푼) 이유 
* 오타로 발생한 소스코드 상의 에러코드를 식별하지 못함. typeerror: 'builtin_function_or_method' object is not subscriptable ex) ans=min[ans,nxt] 괄호오타
* 다익스라 알고리즘을 떠올려야 하나, DFS로만 문제 구현

## 문제해결 아이디어

### 개념
* 표 편집 문제에서는 특정 자료구조에 **삽입, 삭제, 검색**과 비슷한 행위들을 반복하여 수행해야 함을 알 수 있다.

#### 오류코드(수정필요!)
```python
#https://kjhoon0330.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%91%9C-%ED%8E%B8%EC%A7%91-Python

def solution(n, start, end, roads, traps):
    isTraps = [0] * (n + 1)
    isVisited = [0] * (n + 1)
    for trap in traps:
        isTraps[trap] = 1
    # 정방향 Y->X 이동시 Cost
    board = []
    for _ in range(n + 1):
        board.append([0 for _ in range(n + 1)])

    links=dict()
    for i in range(1,n+1):
       links[i]=[]
    reverse = dict()
    for i in range(1, n + 1):
        reverse[i] = []
    for road in roads:
        sp, ep, cost = road
        links[sp].append(ep)
        reverse[ep].append(sp)
        # 서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다.
        if board[sp][ep] == 0:
            board[sp][ep] = cost
        else:
            board[sp][ep] = min(board[sp][ep], cost)
    print(links)
    print(reverse)
    print(traps)
    # print(reverse)
    answer = 2170000000

    def DFS(pre, now, timeCost, isReverse):
        # 내부에 함수만들고 변수를 끌어다쓸때 nonlocal 선언
        nonlocal answer
        if timeCost >= answer:
            return
        if now == end:
            print('없넹')
            if isReverse:
                answer = min(answer, timeCost + board[now][pre])
            else:
                answer = min(answer, timeCost + board[pre][now])


        if isVisited[now] == 1:
            return
        else:
            # 현재 유의미한 값
            isVisited[nxt] = 1
            if isTraps[now] == 1:
                isReverse = True
            else:
                isReverse = False

                # 뒤집힌경우
            if isReverse:
                for nxt in reverse[now]:
                    # 왜 nxt는 안되고..
                    print(now, nxt, timeCost + board[pre][now], isReverse)
                    DFS(now, nxt, timeCost + board[pre][now], isReverse)


            else:
                for nxt in links[now]:
                    # 왜 nxt는 안되고..
                    print(now, nxt, timeCost + board[pre][now], isReverse)
                    DFS(now,nxt,timeCost+board[pre][now],isReverse)
                    # 기존 DFS는되지?;;
                    # DFS(pre,now,timeCost,isReverse)
            isVisited[nxt] = 0

    isReverse = False

    isVisited[start]=1

    DFS(0, start, 0, isReverse)

    return answer

n=4
start=1
end=4
roads=[[1, 2, 1], [3, 2, 1], [2, 4, 1]]
traps=[2,3]
print(solution(n, start, end, roads, traps))
```


#### 링크드리스트 개념
1. 링크드리스트는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 이름에서 말하듯이 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다. [링크드리스트 개념 링크참조](https://velog.io/@woga1999/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8)
2. 링크드리스틀 구현하기위해 별도 클래스를 구현할 수도 있지만 dict() 자료구조를 활용하면, 구현도 간편하고 특정 열에 대한 검색시간도 줄일 수 있다.
<img src="https://wayhome25.github.io/assets/post-img/cs/linked-list-new.png">
<img src="https://wayhome25.github.io/assets/post-img/cs/linked-list2.png">




### 핵심
* dict() 자료구조의 링크트리스트 활용한다. **key 값은 열의 번호, value 값은 [ prev 열, next 열 ]**  (시간복잡도 O(1))
* 이러한 방법을 사용하면 U, D 명령 시간복잡도는 최악의 경우에도 O(X)이고 C, Z 명령은 최악의 경우에도 O(1)을 유지한다. 따라서 효율성 테스트를 성공적으로 통과할 수 있음을사전에 알 수 있다. 


### 알고리즘
 1. table[cur] = [prev 열, next 열] 의 링크드리스트를 만든다.
 2. table[0]과 table[n-1] 각각의 시작점, 끝점은 None 값이므로 예외처리해준다. 
 3. 삭제, 복구 명령을 수행할때마다, 각 노드 간 prev, cur, next 변경사항을 함수화한다. 이때 시작점 또는 끝점이 None인 경우를 예외처리한다
 4. U, D와 같은 검색 시에는 이미 링크드리스트로 연결되있으므로 for문을 활용하여 cur값을 변경해준다.  


### 정답코드 

```python
def solution(n, k, cmd):
    cur = k
    table = {i: [i - 1, i + 1] for i in range(n)}
    answer = ['O'] * n
    # 시작점과 끝점 None값 예외처리
    table[0] = [None, 1]
    table[n - 1] = [n - 2, None]
    # stack : 삭제된 링크드리스트 저장
    stack = []
    for c in cmd:
        if c == "C":
            # 삭제
            answer[cur] = 'X'
            prev, next = table[cur]
            stack.append([prev, cur, next])
            if next == None:
                cur = table[cur][0]
            else:
                cur = table[cur][1]
            # 링크드리스트 처리
            if prev == None:
                table[next][0] = None
            elif next == None:
                table[prev][1] = None
            else:
                table[prev][1] = next
                table[next][0] = prev
        elif c == "Z":
            # 복구
            prev, now, next = stack.pop()
            answer[now] = 'O'
            #링크드리스트
            if prev == None:
                table[next][0] = now
            elif next == None:
                table[prev][1] = now
            else:
                table[next][0] = now
                table[prev][1] = now

        else:
            # 커서 이동
            c1, c2 = c.split(' ')
            c2 = int(c2)
            if c1 == 'D':
                for _ in range(c2):
                    cur = table[cur][1]
            else:
                for _ in     range(c2):
                    cur = table[cur][0]
    return ''.join(answer)
```

### 코드이해 TiP 
 1. prev, cur, next 를 수직선상에 그리고, 코드를 리뷰하면 이해가 쉽다.
 2. 본 코드에는 dict()를 활용하였으나, 클래스를 활용한 링크드리스트 적용방법을 공부하자. 

## 참고
* [github 마크다운 : https://ffoorreeuunn.tistory.com/226](https://ffoorreeuunn.tistory.com/226)
* [참고코드1 : https://gusrb3164.github.io/algorithm/2021/08/22/2021-kakao-algorithm1/)
* [다익스르라 알고리즘 기초개념 : https://techblog-history-younghunjo1.tistory.com/247)
